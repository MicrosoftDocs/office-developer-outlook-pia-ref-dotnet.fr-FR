<Type Name="_Items" FullName="Microsoft.Office.Interop.Outlook._Items">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7bd8b181e72530f36fac5524b4ed22a89311b9c6" /><Meta Name="ms.sourcegitcommit" Value="372abf58b21f4fab503d106f0e8c8a2ac45f9332" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="01/12/2019" /><Meta Name="ms.locfileid" Value="27898381" /></Metadata><TypeSignature Language="C#" Value="public interface _Items : System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract _Items implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Office.Interop.Outlook._Items" />
  <TypeSignature Language="VB.NET" Value="Public Interface _Items&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public interface class _Items : System::Collections::IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
    <AssemblyVersion>15.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("00063041-0000-0000-C000-000000000046")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.TypeLibType(4160)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Il s’agit d’une interface principale dans une coclasse COM qui est requis par le code managé pour l’interopérabilité avec l’objet COM correspondant. Utilisez cette interface principale uniquement lorsque la méthode que vous souhaitez utiliser partageant le même nom qu’un événement de l’objet COM ; Dans ce cas, effectuez un cast à cette interface pour appeler la méthode et dans l’interface d’événements le plus récent pour se connecter à l’événement. Sinon, utilisez l’interface .NET est dérivé de la coclasse COM pour accéder aux méthodes, propriétés et événements de l’objet COM. Pour plus d’informations sur l’objet COM, voir <see cref="T:Microsoft.Office.Interop.Outlook.Items" />.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public object Add (object Type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Add([in]object Type) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (Optional Type As Object) As Object" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(95)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Type" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Type">Le type d’élément Outlook pour le nouvel élément. Spécifie une <see cref="P:Microsoft.Office.Interop.Outlook._MailItem.MessageClass" /> pour créer des formulaires personnalisés. Peut être une des constantes <b>OlItemType</b> suivantes : <b>olAppointmentItem</b>, <b>olContactItem</b>, <b>olJournalItem</b>, <b>olMailItem</b>, <b>olNoteItem</b>, <b>olPostItem</b>, ou <b>olTaskItem</b>ou tout message valide classe.</param>
        <summary>Crée un nouvel élément Outlook dans le <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> collection pour le dossier.</summary>
        <returns>Valeur Objet qui représente le nouvel élément Outlook.</returns>
        <remarks><para>Le cas contraire, la propriété <b>Type</b> de l’élément Outlook par défaut pour le type du dossier ou à <see cref="T:Microsoft.Office.Interop.Outlook.MailItem" /> si le dossier parent n’est pas tapé.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.Application Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.Application Application" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::Application ^ Application { Microsoft::Office::Interop::Outlook::Application ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61440)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61440)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Renvoie un <see cref="T:Microsoft.Office.Interop.Outlook.Application" /> object qui représente l’application Outlook de l’objet parent. En lecture seule.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Class">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.OlObjectClass Class { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Office.Interop.Outlook.OlObjectClass Class" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Class" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Class As OlObjectClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::OlObjectClass Class { Microsoft::Office::Interop::Outlook::OlObjectClass get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61450)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61450)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.OlObjectClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Renvoie un <see cref="T:Microsoft.Office.Interop.Outlook.OlObjectClass" /> constante indiquant la classe de l’objet. En lecture seule.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(80)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(80)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Renvoie une valeur d' <b>entier</b> (<b>int</b> en c#) indiquant le nombre d’objets dans la collection spécifiée. En lecture seule.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public object Find (string Filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Find([in]string Filter) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (Filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Find(System::String ^ Filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(98)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Filter">Une chaîne qui spécifie les critères auxquels l’objet retourné doit correspondre.</param>
        <summary>Localise et renvoie un objet d’élément Outlook qui satisfait à la donnée <paramref name="Filter" />.</summary>
        <returns>Valeur Object qui représente un élément Outlook si l’appel réussit ; Renvoie la valeur <b>Nothing</b> (une référence null (Nothing dans Visual Basic) en c#) en cas d’échec.</returns>
        <remarks><para>Pour utiliser la recherche d’indexation de contenu dans le <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> collection, utilisez la <see cref="M:Microsoft.Office.Interop.Outlook._Items.Restrict(System.String)" /> méthode. <b>FindRow</b> renvoie une erreur si <paramref name="Filter" /> contient les mots clés d’indexation de contenu. Pour plus d’informations sur les mots clés d’indexation de contenu, voir <a href="http://go.microsoft.com/fwlink/?LinkId=87947">Filtrage d’éléments à l’aide de mots clés de requête</a></para>
          <para>La méthode renvoie une erreur avec les propriétés suivantes dans le <paramref name="Filter" />: </para>
          <list type="table">
            <item>
              <description>BodyCategoriesChildrenClassCompaniesCompanyLastFirstNoSpaceCompanyLastFirstSpaceOnlyContactNamesContactsConversationIndexDLNameEmail1EntryIDEmail2EntryIDEmail3EntryIDEntryIDHTMLBodyIsOnlineMeetingLastFirstAndSuffixLastFirstNoSpaceAutoResolvedWinnerBodyFormatInternetCodePagePermission</description>
              <description>LastFirstNoSpaceCompanyLastFirstSpaceOnlyLastFirstSpaceOnlyCompanyLastFirstNoSpaceAndSuffixMemberCountNetMeetingAliasNetMeetingAutoStartNetMeetingOrganizerAliasNetMeetingServerNetMeetingTypeRecurrenceStateReplyRecipientsReceivedByEntryIDRecevedOnBehalfOfEntryIDResponseStateSavedSentSubmittedVotingOptionsDownloadStateIsConflictMeetingWorkspaceURL</description>
            </item>
          </list>
          <para>Création de filtre pour les méthodes Rechercher et Restreindre</para>
          <para>La syntaxe du filtre varie selon le type de champ que vous filtrez.</para>
          <para>Chaîne (pour les champs de texte) </para>
          <para>Lors de la recherche des champs de texte, vous pouvez utiliser une apostrophe (') ou entre guillemets (« ») pour délimiter les valeurs qui font partie du filtre. Par exemple, toutes les lignes suivantes fonctionnent correctement lorsque le champ est de taper <b>chaîne</b> (<b>string</b> en c#) </para>
          <para>sFilter = « [NomSociété] = 'Microsoft' » </para>
          <para>sFilter = « [NomSociété] = « « Microsoft » » » </para>
          <para>sFilter = « [NomSociété] = « &amp; Chr (34) &amp; « Microsoft » &amp; Chr (34)</para>
          <para>Lorsqu'il s'agit de spécifier un filtre dans une requête Jet ou DASL, si vous utilisez une paire de guillemets simples pour délimiter une chaîne qui fait partie de ce filtre et que le chaîne contient un autre guillemet simple ou une apostrophe, ajoutez un guillemet simple en guise de caractère d'échappement avant le guillemet simple ou l'apostrophe. Adoptez la même approche si vous utilisez une paire de guillemets doubles pour délimier une chaîne : si la chaîne contient un guillemet double, ajoutez un guillemet double en guise de caractère d'échappement avant le guillemet double.</para>
          <para>Par exemple, dans le filtre DASL chaîne que des filtres pour la propriété <b>Subject</b> est égal au mot ne peut pas, la chaîne de filtre entière est délimitée par une paire de guillemets et la chaîne imbriquée ne peut pas est délimité par une paire de guillemets simples. Il existe trois caractères dont vous avez besoin d’échappement dans cette chaîne de filtre : le guillemet de début et la fin des guillemets doubles pour la référence de propriété de http://schemas.microsoft.com/mapi/proptag/0x0037001f, et l’apostrophe dans la condition de valeur pour le mot ne peut pas. En appliquant les caractères d’échappement appropriés, vous pouvez exprimer la chaîne de filtre comme suit :</para>
          <para>filtre = « @SQL = » «http://schemas.microsoft.com/mapi/proptag/0x0037001f» « = » peut '' t' »</para>
          <para>

 

Vous pouvez également utiliser la fonction chr(34) pour représenter le guillemet double (dont la valeur de caractère ASCII est 34) utilisé comme caractère d’échappement. En utilisant chr(34) à la place d’un caractère d’échappement de type guillemet double, vous pouvez exprimer le dernier exemple comme suit :

 

</para>
          <para>Filter = « @SQL = » &amp; Chr (34) &amp; «http://schemas.microsoft.com/mapi/proptag/0x0037001f» _</para>
          <para>    &amp;Chr (34) &amp; « = » &amp; « ' peut « t » »</para>
          <para>Il est également nécessaire d’utiliser des caractères d’échappement pour les guillemets simples et doubles figurant dans les requêtes DASL à l’aide des opérateurs <b>ci_startswith</b> ou <b>ci_phrasematch</b>. Par exemple, la requête suivante exécute une requête de correspondance d’expression pour can’t dans l’objet du message :

 

</para>
          <para>Filter = « @SQL = » &amp; Chr (34) &amp; «http://schemas.microsoft.com/mapi/proptag/0x0037001E» _</para>
          <para>    &amp;Chr (34) &amp; « ci_phrasematch » &amp; » ' peut « t » »</para>
          <para>Un autre exemple est une chaîne de filtre DASL qui filtre pour la propriété <b>Subject</b> est égale à la mention les éléments de droite, où le document word est placée entre guillemets. Dans ce cas, vous devez échapper par des guillemets doubles englobants comme suit :</para>
          <para>filtre = « @SQL = » «http://schemas.microsoft.com/mapi/proptag/0x0037001f» « = 'droite « ou « sélections » »' »</para>
          <para>Un ensemble de règles d’échappement différent s’applique à une référence de propriété pour les propriétés nommées contenant l’espace, un guillemet simple, double guillemets ou caractère pourcentage. Pour plus d’informations, voir Référencement des propriétés par Espace de noms.</para>
          <para>Date</para>
          <para>Bien que les dates et heures sont généralement stockées avec un format de Date, les méthodes Find et Restrict nécessitent que la date et l’heure est convertie en une représentation de chaîne. Pour vous assurer que la date est mise en forme comme prévu dans Microsoft Outlook, utiliser la fonctionFormat. L’exemple suivant crée un filtre pour trouver tous les contacts qui ont été modifiés après le 15 janvier 1999 à 3:30 P.M. </para>
          <para>sFilter = » [LastModificationTime] &gt; ' » &amp; Format (« 15/1/99 15:30:00 », « ddddd h:nn suffixes ») &amp; » ' »</para>
          <para>Opérateurs booléens</para>
          <para>Les opérateurs Boolean, TRUE/FALSE, YES/NO, ON/OFF, etc, ne doivent pas être convertis en chaîne. Par exemple, pour déterminer si la journalisation est activée pour les contacts, utilisez ce filtre :</para>
          <para>sFilter = « [Journal] = True » </para>
          <para>
            <b>Remarque</b>: Si vous utilisez des guillemets comme séparateurs avec champs booléens, une chaîne vide trouvera les éléments dont les champs comportent la valeur False et toutes les chaînes non vide trouvera les éléments dont les champs comportent la valeur True.</para>
          <para>Mots clés (ou catégories)</para>
          <para>Le champ catégories est de type keywords, est conçu pour contenir plusieurs valeurs. Lors de l’accès par programme, le champCatégories se comporte comme un champ de texte et la chaîne doit correspondre exactement. Les valeurs dans la chaîne de texte sont séparées par une virgule et un espace. Cela signifie généralement que vous ne pouvez pas utiliser les méthodes Rechercher et Restreindre sur un champ de mots clés s’il contient plusieurs valeurs. Par exemple, si vous avez un contact dans la catégorie Professionnel et un contact dans catégories Entreprise et Social, vous ne pouvez pas facilement utiliser les méthodes Rechercher et Restreindre pour récupérer tous les éléments qui se trouvent dans la catégorie Professionnel. Au lieu de cela, vous pouvez parcourir tous les contacts dans le dossier et utiliser la fonction Instr pour tester si la chaîne Entreprise est incluse dans l’ensemble du champ mots clés. </para>
          <para>
            <b>Remarque</b>: une exception possible est si vous limitez le champ catégories à deux, ou un nombre de valeurs faible. Vous pouvez ensuite utiliser les méthodes Rechercher et Restreindre avec l’opérateur logique OU pour récupérer tous les contacts professionnels. Par exemple (dans pseudocode) : « Entreprise » ou « Entreprise, personnel » ou « Personnel, entreprise. » Les chaînes de catégorie ne sont pas sensibles à la casse.</para>
          <para>Entier</para>
          <para>Vous pouvez rechercher les champs Integer avec ou sans guillemets comme délimiteurs. Les filtres suivants retrouveront les contacts qui ont été créés avec Outlook 2000 :
</para>
          <para>sFilter = « [OutlookInternalVersion] = 92711 » </para>
          <para>sFilter = « [OutlookInternalVersion] = '92711' »</para>
          <para>Utilisation des Variables dans le cadre du filtre</para>
          <para>Comme l’illustre l’exemple de la méthode Restrict, vous pouvez utiliser des valeurs à partir de variables comme partie du filtre. L’exemple de code Microsoft Visual Basic suivant illustre la syntaxe qui utilise les variables comme partie du filtre. </para>
          <para>sFullName = « Dan Wilson » </para>
          <para> Cette approche utilise Chr (34) pour délimiter la valeur : sFilter = « [FullName] = « &amp; Chr (34) &amp; sNomComplet &amp; Chr (34) </para>
          <para> Cette approche utilise des guillemets doubles pour délimiter la valeur : sFilter = « [FullName] = « « « &amp; sNomComplet &amp; » « »</para>
          <para>Utilisation d’opérateurs logiques dans le cadre du filtre</para>
          <para>Les opérateurs logiques qui sont autorisés sont AND, OR, et NOT. Voici des variantes de la clause pour la méthodeRestreindre afin que vous puissiez spécifier plusieurs critères.  </para>
          <para>OR : Le code suivant renvoie tous les éléments contacts ayant entreprise ou personnel en tant que catégorie.</para>
          <para>sFilter = « [Catégories] = 'Personal' Or [Catégories] = 'Business' » </para>
          <para>AND : Le code suivant extrait tous les contacts personnels travaillant à Microsoft.</para>
          <para>sFilter = « [Catégories] = 'Personal' et [NomSociété] = 'Microsoft' » </para>
          <para>NOT : Le code suivant extrait tous les contacts personnels qui ne travaillent pas à Microsoft.</para>
          <para>sFilter = « [Catégories] = 'Personal' et non ([NomSociété] = 'Microsoft') »</para>
          <para>Notes supplémentaires</para>
          <para>Si vous essayez d’utiliser les méthodes Find et Restrict avec des champs définis par l’utilisateur, les champs doivent être définis dans le dossier, sinon une erreur se produit. Il est impossible d’effectuer une opération « contient ». Par exemple, vous ne pouvez pas utiliser Rechercher ou Restreindre pour rechercher tous les éléments ayant un mot spécifique dans le champobjet. Au lieu de cela, vous pouvez utiliser la méthode RechercheAvancée , ou vous pouvez parcourir tous les éléments dans le dossier et utiliser la fonctionInStr pour effectuer une recherche dans un champ. Vous pouvez utiliser la méthodeRestreindre permettant de rechercher des éléments qui commencent au sein d’une certaine plage de caractères. Par exemple, pour rechercher tous les contacts avec une dernière nom commençant par la lettre M, utilisez ce filtre : </para>
          <para>sFilter = « [LastName] &gt; 'LZZZ' And [LastName] &lt; n ' »</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="FindNext">
      <MemberSignature Language="C#" Value="public object FindNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object FindNext() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.FindNext" />
      <MemberSignature Language="VB.NET" Value="Public Function FindNext () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindNext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(99)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Après le <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" /> méthode s’exécute, cette méthode recherche et renvoie le prochain élément Outlook dans la collection spécifiée.</summary>
        <returns>Valeur Object qui représente le prochain élément Outlook trouvé dans la collection.</returns>
        <remarks><para> L'opération de recherche part de l'emplacement actuel, qui correspond à l'expression précédemment définie à l'aide de la méthode <b>Find</b>.</para>
          <para>La méthode renvoie un élément Outlook d’objet si l’appel réussit ; elle renvoie <b>Nothing</b> (une référence null (Nothing dans Visual Basic) en c#) en cas d’échec.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFirst">
      <MemberSignature Language="C#" Value="public object GetFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetFirst() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFirst () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetFirst();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(86)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Renvoie le premier objet de la collection.</summary>
        <returns>Valeur Object qui représente le premier objet contenu dans la collection.</returns>
        <remarks><para>Renvoie <b>Nothing</b> si aucun objet premier existe, par exemple, s’il n’y a aucuns objets dans la collection. Pour garantir le bon fonctionnement de la <b>GetFirst</b>, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" />, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />, et <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> dans une collection volumineuse, appelez <b>GetFirst</b> avant <b>cette collection GetNext</b> et <b>GetLast</b> avant d’appeler <b>GetPrevious </b>. Pour vous assurer que vous sont toujours vos appels sur la même collection, créez une variable explicite qui fait référence à la collection avant d’entrer dans la boucle.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLast">
      <MemberSignature Language="C#" Value="public object GetLast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetLast() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetLast" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLast () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetLast();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(88)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Renvoie le dernier objet de la collection.</summary>
        <returns>Valeur Object qui représente le dernier objet contenu dans la collection.</returns>
        <remarks><para>Elle renvoie la <b>valeur Nothing</b> si aucun objet n’existe, par exemple, si la collection est vide. Pour garantir le bon fonctionnement de le <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />, <b>GetLast</b>, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />, et <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> dans une collection volumineuse, appelez <b>GetFirst</b> avant d’appeler <b>GetNext</b> dans cette collection et appelez <b>GetLast</b> avant d’appeler <b>GetPrevious </b>. Pour vous assurer que vous sont toujours vos appels sur la même collection, créez une variable explicite qui fait référence à la collection avant d’entrer dans la boucle.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNext">
      <MemberSignature Language="C#" Value="public object GetNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetNext() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNext () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetNext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(87)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Renvoie l'objet suivant de la collection.</summary>
        <returns>Valeur Object qui représente l'objet suivant contenu dans la collection.</returns>
        <remarks><para>Elle renvoie la <b>valeur Nothing</b> si aucun objet suivant n’existe, par exemple, si déjà placé à la fin de la collection. Pour garantir le bon fonctionnement de le <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" />, <b>GetNext</b>, et <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> dans une collection volumineuse, appelez <b>GetFirst</b> avant d’appeler <b>GetNext</b> dans cette collection et appelez <b>GetLast</b> avant d’appeler <b>GetPrevious </b>. Pour vous assurer que vous sont toujours vos appels sur la même collection, créez une variable explicite qui fait référence à la collection avant d’entrer dans la boucle.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrevious">
      <MemberSignature Language="C#" Value="public object GetPrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetPrevious() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPrevious () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetPrevious();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(89)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Renvoie l'objet précédent de la collection.</summary>
        <returns>Valeur Object qui représente l'objet précédent contenu dans la collection.</returns>
        <remarks><para>Elle renvoie la <b>valeur Nothing</b> si aucun objet précédent n’existe, par exemple, si le début de la collection. Pour garantir le bon fonctionnement de le <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" />, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />, et les méthodes <b>GetPrevious</b> dans une collection volumineuse, appelez <b>GetFirst</b> avant d’appeler <b>GetNext</b> dans cette collection et appelez <b>GetLast</b> avant d’appeler <b> GetPrevious</b>. Pour vous assurer que vous sont toujours vos appels sur la même collection, créez une variable explicite qui fait référence à la collection avant d’entrer dans la boucle.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeRecurrences">
      <MemberSignature Language="C#" Value="public bool IncludeRecurrences { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeRecurrences" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.IncludeRecurrences" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeRecurrences As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeRecurrences { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Renvoie un <b>type Boolean</b> (<b>bool</b> en c#) qui indique <b>True</b> si le <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> collection inclut des périodicités. Lecture-écriture.</summary>
        <value>To be added.</value>
        <remarks><para>Cette propriété n’a d’effet que si la collection <b>Items</b> contient des rendez-vous et n’est pas triée par n’importe quelle propriété autre que <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.Start" /> dans l’ordre croissant. La valeur par défaut est <b>False</b>. Utilisez cette propriété lorsque vous souhaitez récupérer tous les rendez-vous pour une date donnée, où les rendez-vous périodiques n’apparaissant normalement pas, car ils ne sont pas associés à une date spécifique. Si vous avez besoin trier et filtrer les éléments de rendez-vous qui contiennent des rendez-vous périodiques, vous devez le faire dans cet ordre : trier les éléments dans l’ordre croissant, attribuez à <b>IncludeRecurrences</b> <b>la valeur True</b>et puis filtrer les éléments. Pour un exemple de code illustrant cet ordre, voir l’exemple ci-dessous. Si la collection comprend des rendez-vous périodiques sans date de fin, la définition de la propriété sur <b>True</b> peut entraîner la collection être infinie. Veillez à inclure un test pour ce dans les boucles. Vous ne devez pas utiliser la propriété <b>Count</b> de la collection <b>Items</b> lors d’une itération de la collection <b>d’éléments</b> dont la propriété <b>IncludeRecurrence prend</b> la valeur <b>True</b>. La valeur de <b>nombre</b> sera une valeur non définie.</para>
          <para>
            <b>Mise en garde</b>: filtrage sur une liste triée des occurrences entraîne la propriété IncludeRecurrences de fonctionner comme prévu. Par exemple, la séquence suivante renvoie toutes les occurrences du rendez-vous ; périodique et non périodique : (1) trier par propriété Start (2) définir la propriété sur false (3) appeler Restrict (autrement dit, le filtre).</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[object Index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(Index As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ Index); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Index">Numéro d'index de l'objet ou valeur utilisée pour établir une correspondance avec la propriété par défaut d'un objet de la collection.</param>
        <summary>Renvoie un élément Outlook d’une collection.</summary>
        <value>Valeur Object qui représente l'objet spécifié.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public object Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Parent" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Parent { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61441)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61441)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Renvoie la valeur de type <b>Object</b> parent de l’objet spécifié. En lecture seule.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RawTable">
      <MemberSignature Language="C#" Value="public object RawTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object RawTable" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.RawTable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawTable As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ RawTable { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(90)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(90)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.TypeLibFunc(64)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cet objet, ce membre ou cette énumération est déconseillé et n'est pas destiné à être utilisé dans votre code.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (int Index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove([in]int32 Index) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (Index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(int Index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(84)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Index">Valeur d’index à base 1 de l’objet dans la collection.</param>
        <summary>Supprime un objet de la collection.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetColumns">
      <MemberSignature Language="C#" Value="public void ResetColumns ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetColumns() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.ResetColumns" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetColumns ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetColumns();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(93)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface les propriétés qui ont été mis en cache avec les <see cref="M:Microsoft.Office.Interop.Outlook._Items.SetColumns(System.String)" /> méthode.</summary>
        <remarks><para>Toutes les propriétés demeurent accessibles après l'appel de la méthode <b>ResetColumns</b>. La méthode <b>SetColumns</b> doit être réutilisée pour permettre le stockage de nouvelles propriétés. La méthode <b>ResetColumns</b> n'a aucun effet si la méthode <b>SetColumns</b> n'a pas été appelée au préalable.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Restrict">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.Items Restrict (string Filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Office.Interop.Outlook.Items Restrict([in]string Filter) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Restrict(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Restrict (Filter As String) As Items" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Office::Interop::Outlook::Items ^ Restrict(System::String ^ Filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(100)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.Items</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Filter">Expression de filtre chaîne à appliquer. Pour plus d’informations, voir la <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" /> méthode.</param>
        <summary>Applique un filtre à la <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> collection, retournant une nouvelle collection contenant tous les éléments d’origine qui correspondant au filtre.</summary>
        <returns>Une collection <b>Items</b> qui représente les éléments de la collection <b>Items</b> d’origine qui correspond au filtre.</returns>
        <remarks><para>Cette méthode est une alternative à l’aide de la <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" /> méthode ou <see cref="M:Microsoft.Office.Interop.Outlook._Items.FindNext" /> pour parcourir des éléments spécifiques dans une collection. Les méthodes <b>Rechercher</b> ou <b>RechercherSuivant</b> sont plus rapides s’il existe un petit nombre d’éléments de filtrage. La méthode <b>Restreindre</b> est sensiblement plus rapide s’il y a un grand nombre d’éléments dans la collection, en particulier si seuls quelques éléments dans une grande collection doivent être trouvés.</para>
          <para>
            <b>Remarque</b>: Si vous utilisez des champs définis par l’utilisateur dans le cadre d’une clause <b>Find</b> ou <b>Restrict</b> , les champs définis par l’utilisateur doivent exister dans le dossier. Dans le cas contraire, le code génère une erreur indiquant que le champ est inconnu. Vous pouvez ajouter un champ à un dossier en affichant le Sélecteur de champs et en cliquant sur Nouveau.</para>
          <para>Cette méthode ne peut pas être utilisée et génère une erreur avec les propriétés suivantes :</para>
          <list type="table">
            <item>
              <description>BodyCategoriesChildrenClassCompaniesCompanyLastFirstNoSpaceCompanyLastFirstSpaceOnlyContactNamesContactsConversationIndexDLNameEmail1EntryIDEmail2EntryIDEmail3EntryIDEntryIDHTMLBodyIsOnlineMeetingLastFirstAndSuffixLastFirstNoSpaceAutoResolvedWinnerBodyFormatInternetCodePagePermission</description>
              <description>LastFirstNoSpaceCompanyLastFirstSpaceOnlyLastFirstSpaceOnlyCompanyLastFirstNoSpaceAndSuffixMemberCountNetMeetingAliasNetMeetingAutoStartNetMeetingOrganizerAliasNetMeetingServerNetMeetingTypeRecurrenceStateReplyRecipientsReceivedByEntryIDRecevedOnBehalfOfEntryIDResponseStateSavedSentSubmittedVotingOptionsDownloadStateIsConflictMeetingWorkspaceURL</description>
            </item>
          </list>
          <para>Création de filtre pour les méthodes Rechercher et Restreindre</para>
          <para>La syntaxe du filtre varie selon le type de champ que vous filtrez.</para>
          <para>Chaîne (pour les champs de texte) </para>
          <para>Lors de la recherche des champs de texte, vous pouvez utiliser une apostrophe (') ou entre guillemets (« »), pour délimiter les valeurs qui font partie du filtre. Par exemple, toutes les lignes suivantes fonctionnent correctement lorsque le champ est de taper <b>chaîne</b> (<b>string</b> en c#) </para>
          <para>sFilter = « [NomSociété] = 'Microsoft' » </para>
          <para>sFilter = « [NomSociété] = « « Microsoft » » » </para>
          <para>sFilter = « [NomSociété] = « &amp; Chr (34) &amp; « Microsoft » &amp; Chr (34)</para>
          <para>Lorsqu'il s'agit de spécifier un filtre dans une requête Jet ou DASL, si vous utilisez une paire de guillemets simples pour délimiter une chaîne qui fait partie de ce filtre et que le chaîne contient un autre guillemet simple ou une apostrophe, ajoutez un guillemet simple en guise de caractère d'échappement avant le guillemet simple ou l'apostrophe. Adoptez la même approche si vous utilisez une paire de guillemets doubles pour délimier une chaîne : si la chaîne contient un guillemet double, ajoutez un guillemet double en guise de caractère d'échappement avant le guillemet double.</para>
          <para>Par exemple, dans le filtre DASL chaîne que des filtres pour la propriété <b>Subject</b> est égal au mot ne peut pas, la chaîne de filtre entière est délimitée par une paire de guillemets et la chaîne imbriquée ne peut pas est délimité par une paire de guillemets simples. Il existe trois caractères dont vous avez besoin d’échappement dans cette chaîne de filtre : le guillemet de début et la fin des guillemets doubles pour la référence de propriété de http://schemas.microsoft.com/mapi/proptag/0x0037001f, et l’apostrophe dans la condition de valeur pour le mot ne peut pas. En appliquant les caractères d’échappement appropriés, vous pouvez exprimer la chaîne de filtre comme suit :</para>
          <para>filtre = « @SQL = » «http://schemas.microsoft.com/mapi/proptag/0x0037001f» « = » peut '' t' »</para>
          <para>

 

Vous pouvez également utiliser la fonction chr(34) pour représenter le guillemet double (dont la valeur de caractère ASCII est 34) utilisé comme caractère d’échappement. En utilisant chr(34) à la place d’un caractère d’échappement de type guillemet double, vous pouvez exprimer le dernier exemple comme suit :

 

</para>
          <para>Filter = « @SQL = » &amp; Chr (34) &amp; «http://schemas.microsoft.com/mapi/proptag/0x0037001f» _</para>
          <para>    &amp;Chr (34) &amp; « = » &amp; « ' peut « t » »</para>
          <para>Il est également nécessaire d’utiliser des caractères d’échappement pour les guillemets simples et doubles figurant dans les requêtes DASL à l’aide des opérateurs <b>ci_startswith</b> ou <b>ci_phrasematch</b>. Par exemple, la requête suivante exécute une requête de correspondance d’expression pour can’t dans l’objet du message :

 

</para>
          <para>Filter = « @SQL = » &amp; Chr (34) &amp; «http://schemas.microsoft.com/mapi/proptag/0x0037001E» _</para>
          <para>    &amp;Chr (34) &amp; « ci_phrasematch » &amp; » ' peut « t » »</para>
          <para>Un autre exemple est une chaîne de filtre DASL qui filtre pour la propriété <b>Subject</b> est égale à la mention les éléments de droite, où le document word est placée entre guillemets. Dans ce cas, vous devez échapper par des guillemets doubles englobants comme suit :</para>
          <para>filtre = « @SQL = » «http://schemas.microsoft.com/mapi/proptag/0x0037001f» « = 'droite « ou « sélections » »' »</para>
          <para>Un ensemble de règles d’échappement différent s’applique à une référence de propriété pour les propriétés nommées contenant l’espace, un guillemet simple, double guillemets ou caractère pourcentage. Pour plus d’informations, voir Référencement des propriétés par Espace de noms.</para>
          <para>Date</para>
          <para>Bien que les dates et heures sont généralement stockées avec un format de Date, <b>recherchez</b> et méthodes <b>Restrict</b> nécessitent que la date et l’heure être converti en une représentation de chaîne. Pour vous assurer que la date est mise en forme comme prévu dans Microsoft Outlook, utiliser la fonction<b>Format</b>. L’exemple suivant crée un filtre pour trouver tous les contacts qui ont été modifiées après le 15 janvier 1999 à 3:30 P.M. </para>
          <para>sFilter = » [LastModificationTime] &gt; ' » &amp; Format (« 15/1/99 15:30:00 », « ddddd h:nn suffixes ») &amp; » ' »</para>
          <para>Opérateurs booléens</para>
          <para>Les opérateurs Boolean, TRUE/FALSE, YES/NO, ON/OFF, etc, ne doivent pas être convertis en chaîne. Par exemple, pour déterminer si la journalisation est activée pour les contacts, utilisez ce filtre :</para>
          <para>sFilter = « [Journal] = True » </para>
          <para>
            <b>Remarque</b>: Si vous utilisez des guillemets comme séparateurs avec champs <b>booléens</b> , une chaîne vide trouvera les éléments dont les champs comportent la <b>valeur False</b> et toutes les chaînes non vide trouvera les éléments dont les champs comportent <b>la valeur True</b>. </para>
          <para>Mots clés (ou catégories)</para>
          <para>Le champ catégories est de type keywords, est conçu pour contenir plusieurs valeurs. Lors de l’accès par programme, le champCatégories se comporte comme un champ de texte et la chaîne doit correspondre exactement. Les valeurs dans la chaîne de texte sont séparées par une virgule et un espace. Cela signifie généralement que vous ne pouvez pas utiliser les méthodes <b>Rechercher</b> et <b>Restreindre</b> sur un champ de mots clés s’il contient plusieurs valeurs. Par exemple, si vous avez un contact dans la catégorie Professionnel et un contact dans catégories Entreprise et Social, vous ne pouvez pas facilement utiliser les méthodes <b>Rechercher</b> et <b>Restreindre</b> pour récupérer tous les éléments qui se trouvent dans la catégorie Professionnel. Au lieu de cela, vous pouvez parcourir tous les contacts dans le dossier et utiliser la fonction <b>Instr</b> pour tester si la chaîne Entreprise est incluse dans l’ensemble du champ mots clés. </para>
          <para>
            <b>Remarque</b>: une exception possible est si vous limitez le champ catégories à deux, ou un nombre de valeurs faible. Vous pouvez ensuite utiliser les méthodes <b>Rechercher</b> et <b>Restreindre</b> avec l’opérateur logique OU pour récupérer tous les contacts professionnels. Par exemple (dans pseudocode) : « Entreprise » ou « Entreprise, personnel » ou « Personnel, entreprise. » Les chaînes de catégorie ne sont pas sensibles à la casse. </para>
          <para>Entier</para>
          <para>Vous pouvez rechercher les champs <b>Integer</b> avec ou sans les guillemets comme séparateurs. Les filtres suivants retrouveront les contacts qui ont été créés à l’aide d’Outlook 2000 : </para>
          <para>sFilter = « [OutlookInternalVersion] = 92711 » </para>
          <para>sFilter = « [OutlookInternalVersion] = '92711' »</para>
          <para>Utilisation des Variables dans le cadre du filtre</para>
          <para>Comme l’exemple de la méthode <b>Restreindre</b>l’illustre, vous pouvez utiliser des valeurs de variables dans le cadre du filtre. L’exemple de code Microsoft Visual Basic suivant illustre la syntaxe qui utilise les variables comme partie du filtre. </para>
          <para>sFullName = « Dan Wilson » </para>
          <para>' Cette approche utilise Chr (34) pour délimiter la valeur. </para>
          <para>sFilter = « [FullName] = « &amp; Chr (34) &amp; sNomComplet &amp; Chr (34) </para>
          <para>' Cette approche utilise des guillemets doubles pour délimiter la valeur. </para>
          <para>sFilter = « [FullName] = « « « &amp; sNomComplet &amp; » « »</para>
          <para>Utilisation d’opérateurs logiques dans le cadre du filtre</para>
          <para>Les opérateurs logiques qui sont autorisés sont AND, OR, et NOT. Les éléments suivants sont des variantes de la clause pour la méthode <b>Restrict</b> vous pouvez spécifier plusieurs critères.  </para>
          <para>OR : Le code suivant renvoie tous les éléments contacts ayant entreprise ou personnel en tant que catégorie.</para>
          <para>sFilter = « [Catégories] = 'Personal' Or [Catégories] = 'Business' » </para>
          <para>AND : Le code suivant extrait tous les contacts personnels travaillant à Microsoft.</para>
          <para>sFilter = « [Catégories] = 'Personal' et [NomSociété] = 'Microsoft' » </para>
          <para>NOT : Le code suivant extrait tous les contacts personnels qui ne travaillent pas à Microsoft.</para>
          <para>sFilter = « [Catégories] = 'Personal' et non ([NomSociété] = 'Microsoft') »</para>
          <para>Notes supplémentaires</para>
          <para>Si vous essayez d’utiliser les méthodes<b>Rechercher</b> ou <b>Restreindre</b> avec des champs définis par l’utilisateur, les champs doivent être définis dans le dossier, sinon une erreur se produit. Il est impossible d’effectuer une opération « contient ». Par exemple, vous ne pouvez pas utiliser <b>Rechercher</b> ou <b>Restreindre</b> pour rechercher tous les éléments ayant un mot spécifique dans le champobjet. Au lieu de cela, vous pouvez utiliser la <see cref="M:Microsoft.Office.Interop.Outlook._Application.AdvancedSearch(System.String,System.Object,System.Object,System.Object)" /> méthode, ou vous pouvez une boucle sur tous les éléments dans le dossier et utiliser la fonction <b>InStr</b> pour effectuer une recherche dans un champ. Vous pouvez utiliser la méthode<b>Restreindre</b> permettant de rechercher des éléments qui commencent au sein d’une certaine plage de caractères. Par exemple, pour rechercher tous les contacts avec une dernière nom commençant par la lettre M, utilisez ce filtre : </para>
          <para>sFilter = « [LastName] &gt; 'LZZZ' And [LastName] &lt; n ' »</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.NameSpace Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.NameSpace Session" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As NameSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::NameSpace ^ Session { Microsoft::Office::Interop::Outlook::NameSpace ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61451)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61451)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.NameSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Renvoie le <see cref="T:Microsoft.Office.Interop.Outlook.NameSpace" /> objet pour la session active. En lecture seule.</summary>
        <value>To be added.</value>
        <remarks><para>La propriété <b>Session</b> et la <see cref="M:Microsoft.Office.Interop.Outlook._Application.GetNamespace(System.String)" /> méthode peut être utilisée de façon interchangeable pour obtenir l’objet <b>NameSpace</b> pour la session active. Les deux membres ont la même fonction. Par exemple, les paires d’instructions suivantes effectuent la même fonction :</para>
          <code>Dim objNamespace As Outlook.NameSpace = _
    Application.GetNamespace("MAPI")</code>
          <code>Dim objSession As Outlook.NameSpace = Application.Session</code>
          <code>Outlook.NameSpace objNamespace = 
    Application.GetNamespace("MAPI");</code>
          <code>Outlook.NameSpace objSession = Application.Session;</code>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="SetColumns">
      <MemberSignature Language="C#" Value="public void SetColumns (string Columns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetColumns([in]string Columns) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.SetColumns(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetColumns (Columns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetColumns(System::String ^ Columns);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(92)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Columns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Columns">Chaîne qui contient les noms des propriétés à mettre en chache. Les noms de propriétés sont délimités par des virgules dans cette chaîne.</param>
        <summary>Met en cache certaines propriétés d’un élément de la collection pour permettre d’y accéder très rapidement.</summary>
        <remarks><para>La méthode <b>SetColumns</b> est utile pour itérer la <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> collection. Si vous n’utilisez pas cette méthode, Microsoft Outlook doit ouvrir chaque élément pour accéder à la propriété. Avec la méthode <b>SetColumns</b> , Outlook vérifie uniquement les propriétés que vous avez mis en cache et fournit un accès rapide et en lecture seule à ces propriétés.</para>
          <para>Après avoir appliqué la méthode <b>SetColumns</b> sur des propriétés spécifiques de la collection, vous ne peut pas lire d’autres propriétés de cette collection ; les propriétés qui ne sont pas mis en cache sont renvoyées vides. Vous ne peuvent pas écrire soit à une des propriétés de cette collection. Sinon, si vous avez besoin d’un accès en lecture-écriture et rapide à un ensemble d’éléments, utilisez la <see cref="T:Microsoft.Office.Interop.Outlook.Table" /> objet.</para>
          <para>				La méthode 
            <b>SetColumns</b> ne peut pas être utilisée avec les propriétés qui renvoient un objet (une erreur sera générée). Elle ne peut pas être utilisée avec les propriétés suivantes :

 























 






















 
</para>
          <list type="table">
            <item>
              <description>AutoResolvedWinner</description>
              <description>InternetCodePage</description>
            </item>
            <item>
              <description>Body</description>
              <description>MeetingWorkspaceURL</description>
            </item>
            <item>
              <description>BodyFormat</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.MemberCount" />
              </description>
            </item>
            <item>
              <description>Categories</description>
              <description>ReceivedByEntryID</description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.Children" />
              </description>
              <description>ReceivedOnBehalfOfEntryID</description>
            </item>
            <item>
              <description>Classe</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.RecurrenceState" />
              </description>
            </item>
            <item>
              <description>Sociétés</description>
              <description>ReplyRecipients</description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.DLName" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._TaskItem.ResponseState" />
              </description>
            </item>
            <item>
              <description>DownloadState</description>
              <description>Saved</description>
            </item>
            <item>
              <description>EntryID</description>
              <description>Sent</description>
            </item>
            <item>
              <description>HTMLBody</description>
              <description>Submitted</description>
            </item>
            <item>
              <description>IsConflict</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._MailItem.VotingOptions" />
              </description>
            </item>
          </list>
          <para>La propriété <b>ConversationIndex</b> ne peut pas être mise en cache à l’aide de la méthode <b>SetColumns</b>. Toutefois, cette propriété ne génèrera pas d’erreur, contrairement aux autres propriétés répertoriées ci-dessus.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (string Property, object Descending);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort([in]string Property, [in]object Descending) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Sort(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (Property As String, Optional Descending As Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(97)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Property" Type="System.String" />
        <Parameter Name="Descending" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Property">Le nom de la propriété utilisé pour le tri, qui peut-être être placés entre crochets, par exemple, « [NomSociété] ». Propriétés définies par l’utilisateur qui contiennent des espaces doivent être placés entre crochets. Peut-être pas une propriété de type keywords définies par l’utilisateur, et ne peut pas être une propriété à valeurs multiples, par exemple une catégorie. Pour les propriétés définies par l’utilisateur, la propriété doit figurer dans la collection <b>UserDefinedProperties</b> pour <see cref="P:Microsoft.Office.Interop.Outlook._Items.Parent" />, qui représente le <see cref="T:Microsoft.Office.Interop.Outlook.Folder" /> objet qui contient les éléments.</param>
        <param name="Descending">Cet argument à la valeur <b>True</b> pour un tri par ordre décroissant. La valeur par défaut est <b>False</b> (croissant).</param>
        <summary>Trie la collection d'éléments en fonction de la propriété spécifiée. L'index de cette collection est ramené à 1 après exécution de cette méthode.</summary>
        <remarks><para>La méthode 
            <b>Sort</b> affecte uniquement l'ordre des éléments d'une collection. Elle n'affecte pas l'ordre des éléments dans un affichage d'explorateur.
</para>
          <para>
            <b>Tri</b> ne peut pas être utilisée et génère une erreur si le <paramref name="property" /> paramètre est une des propriétés suivantes :                </para>
          <list type="table">
            <item>
              <description>
                <b>Catégories</b>
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstSpaceOnly" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.Children" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstSpaceOnlyCompany" />
              </description>
            </item>
            <item>
              <description>
                <b>Classe</b>
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.MemberCount" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.CompanyLastFirstNoSpace" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.NetMeetingAlias" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.CompanyLastFirstSpaceOnly" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.RecurrenceState" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.DLName" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._TaskItem.ResponseState" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstAndSuffix" />
              </description>
              <description>
                <b>Enregistré</b>
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstNoSpace" />
              </description>
              <description>
                <b>Envoyé</b>
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstNoSpaceCompany" />
              </description>
              <description />
            </item>
          </list>
          <para> </para></remarks>
      </Docs>
    </Member>
  </Members>
</Type>
