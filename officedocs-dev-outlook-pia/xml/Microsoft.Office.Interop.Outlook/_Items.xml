<Type Name="_Items" FullName="Microsoft.Office.Interop.Outlook._Items">
  <Metadata><Meta Name="ms.openlocfilehash" Value="90ccbcb3fe07f548327e1919c5fa54fecbde32ba" /><Meta Name="ms.sourcegitcommit" Value="8bffa304e2953ca61fa94459dd08997552262640" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="04/05/2019" /><Meta Name="ms.locfileid" Value="31479561" /></Metadata><TypeSignature Language="C#" Value="public interface _Items : System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract _Items implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Office.Interop.Outlook._Items" />
  <TypeSignature Language="VB.NET" Value="Public Interface _Items&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public interface class _Items : System::Collections::IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
    <AssemblyVersion>15.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("00063041-0000-0000-C000-000000000046")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.TypeLibType(4160)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Il s'agit d'une interface principale dans une coclasse COM qui est requise par du code managé en vue de son interopérabilité avec l'objet COM correspondant. Utilisez cette interface principale uniquement lorsque la méthode que vous voulez utiliser partage le même nom qu'un événement de l'objet COM ; en l'occurrence, effectuez un transtypage vers cette interface pour appeler la méthode et effectuez un transtypage vers la dernière interface d'événements pour vous connecter à l'événement. Sinon, utilisez l'interface .NET qui est dérivée de la coclasse COM pour accéder aux méthodes, propriétés et événements de l'objet COM. Pour plus d'informations sur l'objet COM <see cref="T:Microsoft.Office.Interop.Outlook.Items" />, voir.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public object Add (object Type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Add([in]object Type) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (Optional Type As Object) As Object" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(95)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Type" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Type">Type d’élément Outlook du nouvel élément. Spécifie <see cref="P:Microsoft.Office.Interop.Outlook._MailItem.MessageClass" /> un pour créer des formulaires personnalisés. Il peut s’agir des constantes <b>OlItemType</b> suivantes : <b>olAppointmentItem</b>, <b>olContactItem</b>, <b>olJournalItem</b>, <b>olMailItem</b>, <b>olNoteItem</b>, <b>olPostItem</b> ou <b>olTaskItem,</b> ou de toute classe de message valide.</param>
        <summary>Crée un nouvel élément Outlook dans la <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> collection du dossier.</summary>
        <returns>Valeur Objet qui représente le nouvel élément Outlook.</returns>
        <remarks><para>Si ce paramètre n'est pas spécifié, la propriété <b>type</b> de l'élément Outlook prend par défaut le type du <see cref="T:Microsoft.Office.Interop.Outlook.MailItem" /> dossier ou la valeur si le dossier parent n'est pas tapé.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.Application Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.Application Application" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::Application ^ Application { Microsoft::Office::Interop::Outlook::Application ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61440)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61440)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Renvoie un <see cref="T:Microsoft.Office.Interop.Outlook.Application" /> Object qui représente l'application Outlook parente pour l'objet. Lecture seule.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Class">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.OlObjectClass Class { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Office.Interop.Outlook.OlObjectClass Class" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Class" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Class As OlObjectClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::OlObjectClass Class { Microsoft::Office::Interop::Outlook::OlObjectClass get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61450)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61450)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.OlObjectClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Renvoie une <see cref="T:Microsoft.Office.Interop.Outlook.OlObjectClass" /> constante indiquant la classe de l'objet. Lecture seule.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(80)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(80)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Renvoie une valeur de type <b>Integer</b> (<b>int</b> en C#) indiquant le nombre d'objets dans la collection spécifiée. Lecture seule.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public object Find (string Filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Find([in]string Filter) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (Filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Find(System::String ^ Filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(98)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Filter">Chaîne qui spécifie les critères auxquels doit correspondre l'objet renvoyé.</param>
        <summary>Localise et renvoie un objet d'élément Outlook qui correspond aux données <paramref name="Filter" />.</summary>
        <returns>Valeur Object qui représente un élément Outlook si l'appel réussit; renvoie <b>Nothing</b> (référence null (Nothing en Visual Basic) en C#) si elle échoue.</returns>
        <remarks><para>Pour utiliser la recherche d'indexation de contenu <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> dans la collection, <see cref="M:Microsoft.Office.Interop.Outlook._Items.Restrict(System.String)" /> utilisez la méthode. <b>FindRow</b> renvoie une erreur si <paramref name="Filter" /> contient des mots clés d'indexation de contenu. Pour plus d'informations sur les mots clés d'indexation de contenu, voir <a href="http://go.microsoft.com/fwlink/?LinkId=87947">filtrage d'éléments à l'aide de mots clés de requête</a></para>
          <para>La méthode renvoie une erreur avec les propriétés suivantes dans le <paramref name="Filter" />: </para>
          <list type="table">
            <item>
              <description>BodyCategoriesChildrenClassCompaniesCompanyLastFirstNoSpaceCompanyLastFirstSpaceOnlyContactNamesContactsConversationIndexDLNameEmail1EntryIDEmail2EntryIDEmail3EntryIDEntryIDHTMLBodyIsOnlineMeetingLastFirstAndSuffixLastFirstNoSpaceAutoResolvedWinnerBodyFormatInternetCodePagePermission</description>
              <description>LastFirstNoSpaceCompanyLastFirstSpaceOnlyLastFirstSpaceOnlyCompanyLastFirstNoSpaceAndSuffixMemberCountNetMeetingAliasNetMeetingAutoStartNetMeetingOrganizerAliasNetMeetingServerNetMeetingTypeRecurrenceStateReplyRecipientsReceivedByEntryIDRecevedOnBehalfOfEntryIDResponseStateSavedSentSubmittedVotingOptionsDownloadStateIsConflictMeetingWorkspaceURL</description>
            </item>
          </list>
          <para>Création de filtre pour les méthodes Rechercher et Restreindre</para>
          <para>La syntaxe du filtre varie selon le type de champ que vous filtrez.</para>
          <para>String (pour les champs de texte) </para>
          <para>Lors de la recherche de champs de texte, vous pouvez utiliser une apostrophe (') ou des guillemets doubles ("") pour délimiter les valeurs qui font partie du filtre. Par exemple, toutes les lignes suivantes fonctionnent correctement lorsque le champ est de type <b>chaîne</b> (<b>String</b> en C#): </para>
          <para>sFilter = "[CompanyName] = 'Microsoft'" </para>
          <para>sFilter = "[CompanyName] =" "Microsoft" "" </para>
          <para>sFilter = "[CompanyName] =" &amp; Chr (34) &amp; "Microsoft" &amp; Chr (34)</para>
          <para>Lorsqu'il s'agit de spécifier un filtre dans une requête Jet ou DASL, si vous utilisez une paire de guillemets simples pour délimiter une chaîne qui fait partie de ce filtre et que le chaîne contient un autre guillemet simple ou une apostrophe, ajoutez un guillemet simple en guise de caractère d'échappement avant le guillemet simple ou l'apostrophe. Adoptez la même approche si vous utilisez une paire de guillemets doubles pour délimier une chaîne : si la chaîne contient un guillemet double, ajoutez un guillemet double en guise de caractère d'échappement avant le guillemet double.</para>
          <para>Par exemple, dans la chaîne de filtre DASL qui filtre la propriété <b>Subject</b> est égale à la valeur de Word not, la chaîne de filtrage entière est délimitée par une paire de guillemets et la chaîne incorporée ne peut pas être délimitée par une paire de guillemets simples. Cette chaîne de filtrage comporte trois caractères que vous devez ignorer: les guillemets de début et de fin pour la référence de propriété de http://schemas.microsoft.com/mapi/proptag/0x0037001f, et l'apostrophe dans la condition de valeur pour le mot est introuvable. En appliquant les caractères d'échappement appropriés, vous pouvez exprimer la chaîne de filtre comme suit :</para>
          <para>Filter = "@SQL=" "http://schemas.microsoft.com/mapi/proptag/0x0037001f" "=" Can' "</para>
          <para>Vous pouvez également utiliser la fonction chr(34) pour représenter le guillemet double (dont la valeur de caractère ASCII est 34) utilisé comme caractère d’échappement. En utilisant chr(34) à la place d’un caractère d’échappement de type guillemet double, vous pouvez exprimer le dernier exemple comme suit :</para>
          <para>Filter = "@SQL=" &amp; Chr (34) &amp; "http://schemas.microsoft.com/mapi/proptag/0x0037001f" _</para>
          <para>    &amp;Chr (34) &amp; "=" &amp; "' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '</para>
          <para>Il est également nécessaire d’utiliser des caractères d’échappement pour les guillemets simples et doubles figurant dans les requêtes DASL à l’aide des opérateurs <b>ci_startswith</b> ou <b>ci_phrasematch</b>. Par exemple, la requête suivante exécute une requête de correspondance d’expression pour can’t dans l’objet du message : </para>
          <para>Filter = "@SQL=" &amp; Chr (34) &amp; "http://schemas.microsoft.com/mapi/proptag/0x0037001E" _</para>
          <para>    &amp;Chr (34) &amp; "ci_phrasematch" &amp; "'ne peut pas'</para>
          <para>Un autre exemple est une chaîne de filtre DASL qui filtre la propriété <b>Subject</b> égale aux mots, où le mot est placé entre guillemets. Dans ce cas, vous devez ajouter des caractères d'échappement pour les guillemets doubles comme suit :</para>
          <para>Filter = "@SQL=" "http://schemas.microsoft.com/mapi/proptag/0x0037001f" "=" droite "" Stuff "" ' "</para>
          <para>Un ensemble de règles d’échappement différent s’applique à une référence de propriété pour les propriétés nommées contenant l’espace, un guillemet simple, double guillemets ou caractère pourcentage. Pour plus d’informations, voir Référencement des propriétés par Espace de noms.</para>
          <para>Date</para>
          <para>Bien que les dates et heures soient généralement stockées avec un format de date, les méthodes Rechercher et restreindre nécessitent que la date et l'heure soient converties en une représentation de chaîne. Pour vérifier que la date est mise en forme comme prévu dans Microsoft Outlook, utilisez la fonction Format. L'exemple de code suivant montre comment créer un filtre pour rechercher tous les contacts modifiés après le 15 janvier 1999 à 15:30. </para>
          <para>sFilter = "[LastModificationTime] &gt; '" &amp; format ("1/15/99 3:30pm", "ddddd h:NN AMPM") &amp; "'"</para>
          <para>Opérateurs booléens</para>
          <para>Les opérateurs Boolean, TRUE/FALSE, YES/NO, ON/OFF, etc, ne doivent pas être convertis en chaîne. Par exemple, pour déterminer si la journalisation est activée pour les contacts, utilisez ce filtre :</para>
          <para>sFilter = "[Journal] = true" </para>
          <para>
            <b>Remarque</b>: Si vous utilisez des guillemets comme délimiteurs avec des champs booléens, une chaîne vide trouvera alors les éléments dont les champs ont la valeur false et toutes les chaînes non vides trouveront les éléments dont les champs ont la valeur true.</para>
          <para>Mots clés (ou catégories)</para>
          <para>Le champ catégories est de type Mots clés, qui est conçu pour contenir plusieurs valeurs. Lorsque vous accédez au champ Catégories via un programme, celui-ci se comporte comme un champ de texte, et la chaîne doit correspondre exactement à la valeur recherchée. Les valeurs dans la chaîne de texte sont séparées par une virgule et un espace. Cela signifie généralement que vous ne pouvez pas utiliser les méthodes Find et Restrict sur un champ de mots clés s'il contient plusieurs valeurs. Par exemple, si un contact appartient à la catégorie Business et si un contact appartient aux catégories Business et Social, il n'est pas facile d'utiliser les méthodes Find et Restrict pour extraire tous les éléments qui se trouvent dans la catégorie Business. Il est préférable, dans ce cas, d'effectuer une recherche dans les contacts du dossier et d'utiliser la fonction Instr pour vérifier si la chaîne « Business » est contenue dans le champ des mots clés. </para>
          <para>
            <b>Remarque</b>: une exception possible est si vous limitez le champ catégories à deux ou un petit nombre de valeurs. Vous pouvez ensuite utiliser les méthodes Rechercher et restreindre avec l'opérateur logique ou pour récupérer tous les contacts professionnels. Par exemple (dans pseudocode) : « Entreprise » ou « Entreprise, personnel » ou « Personnel, entreprise. » Les chaînes de catégorie ne sont pas sensibles à la casse.</para>
          <para>Entier</para>
          <para>Vous pouvez rechercher les champs Integer avec ou sans guillemets comme délimiteurs. Les filtres suivants retrouveront les contacts qui ont été créés avec Outlook 2000 : </para>
          <para>sFilter = "[OutlookInternalVersion] = 92711" </para>
          <para>sFilter = "[OutlookInternalVersion] = ' 92711 '"</para>
          <para>Utilisation de variables comme partie du filtre</para>
          <para>Comme l'illustre l'exemple de la méthode reStrict, vous pouvez utiliser les valeurs des variables dans le cadre du filtre. L'exemple de code Microsoft Visual Basic suivant illustre la syntaxe qui utilise des variables dans le cadre du filtre. </para>
          <para>sFullName = "Dan Wilson" </para>
          <para> Cette approche utilise Chr (34) pour délimiter la valeur: sFilter = "[FullName] &amp; =" Chr ( &amp; 34 &amp; ) sFullName Chr (34) </para>
          <para> Cette approche utilise des guillemets doubles pour délimiter la valeur: sFilter = "[FullName] = &amp; " &amp; "" sFullName "" ""</para>
          <para>Utilisation d’opérateurs logiques dans le cadre du filtre</para>
          <para>Les opérateurs logiques qui sont autorisés sont AND, OR, et NOT. Voici des variantes de la clause pour la méthode reStrict, afin que vous puissiez spécifier plusieurs critères.  </para>
          <para>OR : le code suivant renvoie tous les contacts dont la catégorie est Business ou Personal. </para>
          <para>sFilter = "[categories] = 'personnel'ou [categories] = 'Business'" </para>
          <para>AND : Le code suivant extrait tous les contacts personnels travaillant à Microsoft. </para>
          <para>sFilter = "[categories] = 'Personal'and [CompanyName] = 'Microsoft'" </para>
          <para>NOT : Le code suivant extrait tous les contacts personnels qui ne travaillent pas à Microsoft. </para>
          <para>sFilter = "[categories] = 'personnel'et non ([CompanyName] = 'Microsoft')"</para>
          <para>Notes supplémentaires</para>
          <para>Si vous essayez d'utiliser les méthodes Find ou reStrict avec des champs définis par l'utilisateur, les champs doivent être définis dans le dossier, sinon une erreur se produit. Il n'existe aucun moyen d'effectuer une opération « contains » (contient). Par exemple, vous ne pouvez pas utiliser Find ou Restrict pour rechercher des éléments dont le champ Objet contient un mot particulier. Il est préférable, dans ce cas, d'utiliser la méthode AdvancedSearch ou de parcourir l'ensemble des éléments dans le dossier et d'utiliser la fonction InStr pour effectuer une recherche dans un champ. Vous pouvez utiliser la méthode Restrict pour rechercher des éléments commençant par un caractère particulier. Par exemple, pour rechercher tous les contacts dont le nom de famille commence par la lettre M, utilisez le filtre suivant : </para>
          <para>sFilter = "[nom] &gt; 'LZZZ'et [nom] &lt; 'N'"</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="FindNext">
      <MemberSignature Language="C#" Value="public object FindNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object FindNext() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.FindNext" />
      <MemberSignature Language="VB.NET" Value="Public Function FindNext () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindNext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(99)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Après l' <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" /> exécution de la méthode, cette méthode recherche et renvoie le prochain élément Outlook dans la collection spécifiée.</summary>
        <returns>Valeur Object qui représente le prochain élément Outlook trouvé dans la collection.</returns>
        <remarks><para> L'opération de recherche part de l'emplacement actuel, qui correspond à l'expression précédemment définie à l'aide de la méthode <b>Find</b>.</para>
          <para>La méthode renvoie un objet d'élément Outlook si l'appel réussit; elle renvoie la valeur <b>Nothing</b> (une référence null (Nothing en Visual Basic) en C#) si elle échoue.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFirst">
      <MemberSignature Language="C#" Value="public object GetFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetFirst() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFirst () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetFirst();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(86)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Renvoie le premier objet de la collection.</summary>
        <returns>Valeur Object qui représente le premier objet contenu dans la collection.</returns>
        <remarks><para>Renvoie la <b>valeur Nothing</b> s'il n'existe pas de premier objet, par exemple, s'il n'y a pas d'objets dans la collection. Pour garantir le bon fonctionnement des <b></b>méthodes GetFirst <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" />, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />, et <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> dans une collection de grande taille, appelez <b>GetFirst</b> avant d'appeler <b>GetNext</b> sur cette collection et appelez <b>GetLast</b> avant d'appeler <b>GetPrevious. </b>. Pour vous assurer que vos appels portent sur la même collection, créez une variable explicite qui fait référence à la collection avant d’entrer dans la boucle.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLast">
      <MemberSignature Language="C#" Value="public object GetLast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetLast() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetLast" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLast () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetLast();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(88)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Renvoie le dernier objet de la collection.</summary>
        <returns>Valeur Object qui représente le dernier objet contenu dans la collection.</returns>
        <remarks><para>Elle renvoie la <b>valeur Nothing</b> s'il n'existe pas de dernier objet, par exemple, si la collection est vide. Pour garantir le <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />bon fonctionnement des méthodes, <b>GetLast</b>, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />et <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> des méthodes dans une grande collection, appelez <b>GetFirst</b> avant d'appeler <b>GetNext</b> sur cette collection, puis appelez <b>GetLast</b> avant l'appel de <b>GetPrevious. </b>. Pour vous assurer que vos appels portent sur la même collection, créez une variable explicite qui fait référence à la collection avant d’entrer dans la boucle.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNext">
      <MemberSignature Language="C#" Value="public object GetNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetNext() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNext () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetNext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(87)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Renvoie l'objet suivant de la collection.</summary>
        <returns>Valeur Object qui représente l'objet suivant contenu dans la collection.</returns>
        <remarks><para>Elle renvoie la <b>valeur Nothing</b> s'il n'existe pas d'objet suivant, par exemple, s'il est déjà positionné à la fin de la collection. <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />Pour garantir le bon fonctionnement des méthodes <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" />,, <b>GetNext</b>et <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> méthode dans une grande collection, appelez <b>GetFirst</b> avant d'appeler <b>GetNext</b> sur cette collection, puis appelez <b>GetLast</b> avant l'appel de <b>GetPrevious. </b>. Pour vous assurer que vos appels portent sur la même collection, créez une variable explicite qui fait référence à la collection avant d’entrer dans la boucle.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrevious">
      <MemberSignature Language="C#" Value="public object GetPrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetPrevious() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPrevious () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetPrevious();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(89)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Renvoie l'objet précédent de la collection.</summary>
        <returns>Valeur Object qui représente l'objet précédent contenu dans la collection.</returns>
        <remarks><para>Elle renvoie la <b>valeur Nothing</b> s'il n'existe pas d'objet précédent, par exemple, s'il est déjà positionné au début de la collection. Pour garantir le <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />bon fonctionnement des méthodes <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" />, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />, et <b>GetPrevious</b> dans une grande collection, appelez <b>GetFirst</b> avant d'appeler <b>GetNext</b> sur cette collection, puis appelez <b>GetLast</b> avant d'appeler <b> GetPrevious</b>. Pour vous assurer que vos appels portent sur la même collection, créez une variable explicite qui fait référence à la collection avant d’entrer dans la boucle.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeRecurrences">
      <MemberSignature Language="C#" Value="public bool IncludeRecurrences { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeRecurrences" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.IncludeRecurrences" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeRecurrences As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeRecurrences { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Renvoie une valeur de <b>type Boolean</b> (<b>bool</b> en C#) qui indique <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> <b>true</b> si la collection doit inclure des périodicités. En lecture/écriture</summary>
        <value>To be added.</value>
        <remarks><para>Cette propriété n'a d'effet que si <b></b> la collection Items contient des rendez-vous et n'est <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.Start" /> pas triée par une autre propriété que par ordre croissant. La valeur par défaut est <b>False</b>. Utilisez cette propriété lorsque vous souhaitez récupérer tous les rendez-vous pour une date donnée, où normalement les rendez-vous périodiques ne figureraient pas car ils ne sont pas associés à une date spécifique. Si vous devez trier et filtrer des éléments de rendez-vous qui contiennent des rendez-vous périodiques, vous devez procéder dans cet ordre : triez les éléments par ordre croissant, attribuez à <b>IncludeRecurrences</b> la valeur <b>True</b>, puis filtrez les éléments. Pour un exemple illustrant cet ordre, voir l’exemple ci-dessous. Si la collection comporte des rendez-vous périodiques sans date de fin et que cette propriété a la valeur <b>True</b>, la collection obtenue risque d’être infinie. Pensez à bien tester cette condition dans les boucles. Il est conseillé de ne pas utiliser la propriété <b>Count</b> de la collection <b>Items</b> lorsque vous procédez à une itération de la collection <b>Items</b> alors que la propriété <b>IncludeRecurrence</b> a la valeur <b>True</b>. La valeur de <b>Count</b> sera indéfinie.</para>
          <para>
            <b>Attention</b>: le filtrage sur une liste d'occurrences triée entraîne le fonctionnement de la propriété IncludeRecurrences. Par exemple, la séquence suivante renverra toutes les occurrences de rendez-vous; périodique et non périodique: (1) Trier par propriété de début (2) définir la propriété sur false (3) appel de la propriété reStrict (par exemple, filtre).</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[object Index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(Index As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ Index); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Index">Numéro d'index de l'objet ou valeur utilisée pour établir une correspondance avec la propriété par défaut d'un objet de la collection.</param>
        <summary>Renvoie un élément Outlook d’une collection.</summary>
        <value>Valeur Object qui représente l'objet spécifié.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public object Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Parent" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Parent { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61441)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61441)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Renvoie la valeur de type <b>Object</b> parent de l’objet spécifié. Lecture seule.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RawTable">
      <MemberSignature Language="C#" Value="public object RawTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object RawTable" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.RawTable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawTable As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ RawTable { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(90)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(90)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.TypeLibFunc(64)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cet objet, ce membre ou cette énumération est déconseillé et n’est pas destiné à être utilisé dans votre code.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (int Index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove([in]int32 Index) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (Index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(int Index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(84)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Index">Valeur d'index à base 1 de l'objet dans la collection.</param>
        <summary>Supprime un objet de la collection.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetColumns">
      <MemberSignature Language="C#" Value="public void ResetColumns ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetColumns() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.ResetColumns" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetColumns ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetColumns();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(93)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface les propriétés qui ont été mises en cache à <see cref="M:Microsoft.Office.Interop.Outlook._Items.SetColumns(System.String)" /> l'aide de la méthode.</summary>
        <remarks><para>Toutes les propriétés demeurent accessibles après l'appel de la méthode <b>ResetColumns</b>. La méthode <b>SetColumns</b> doit être réutilisée pour permettre le stockage de nouvelles propriétés. La méthode <b>ResetColumns</b> n'a aucun effet si la méthode <b>SetColumns</b> n'a pas été appelée au préalable.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Restrict">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.Items Restrict (string Filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Office.Interop.Outlook.Items Restrict([in]string Filter) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Restrict(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Restrict (Filter As String) As Items" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Office::Interop::Outlook::Items ^ Restrict(System::String ^ Filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(100)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.Items</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Filter">Expression de filtre du type Chaîne à appliquer. Pour plus d'informations, <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" /> reportez-vous à la méthode.</param>
        <summary>Applique un filtre à la <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> collection, en renvoyant une nouvelle collection contenant tous les éléments de l'objet d'origine qui correspondent au filtre.</summary>
        <returns>Une <b></b> collection Items qui représente les éléments de la <b></b> collection Items d'origine qui correspondent au filtre.</returns>
        <remarks><para>Cette méthode est une alternative à l'utilisation <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" /> de la <see cref="M:Microsoft.Office.Interop.Outlook._Items.FindNext" /> méthode ou de la méthode pour effectuer une itération sur des éléments spécifiques d'une collection. Les méthodes <b>Find</b> et <b>FindNext</b> sont plus rapides que le filtrage si le nombre d'élément est peu élevé. La méthode <b>Restrict</b> est beaucoup plus rapide si la collection comporte de nombreux éléments et particulièrement, si seuls quelques éléments doivent être renvoyés.</para>
          <para>
            <b>Remarque</b>: Si vous utilisez des champs définis par l'utilisateur dans le cadre d'une clause <b>Find</b> ou Restrict, les champs définis par l'utilisateur doivent exister dans le dossier. <b></b> Si ce n'est pas le cas, le code générera un message d'erreur indiquant que ces champs sont inconnus. Pour ajouter un champ à un dossier, il suffit d'afficher le  sélecteur de champs et de cliquer sur Nouveau.</para>
          <para>Cette méthode ne peut pas être utilisée et génère une erreur avec les propriétés suivantes :</para>
          <list type="table">
            <item>
              <description>BodyCategoriesChildrenClassCompaniesCompanyLastFirstNoSpaceCompanyLastFirstSpaceOnlyContactNamesContactsConversationIndexDLNameEmail1EntryIDEmail2EntryIDEmail3EntryIDEntryIDHTMLBodyIsOnlineMeetingLastFirstAndSuffixLastFirstNoSpaceAutoResolvedWinnerBodyFormatInternetCodePagePermission</description>
              <description>LastFirstNoSpaceCompanyLastFirstSpaceOnlyLastFirstSpaceOnlyCompanyLastFirstNoSpaceAndSuffixMemberCountNetMeetingAliasNetMeetingAutoStartNetMeetingOrganizerAliasNetMeetingServerNetMeetingTypeRecurrenceStateReplyRecipientsReceivedByEntryIDRecevedOnBehalfOfEntryIDResponseStateSavedSentSubmittedVotingOptionsDownloadStateIsConflictMeetingWorkspaceURL</description>
            </item>
          </list>
          <para>Création de filtre pour les méthodes Rechercher et Restreindre</para>
          <para>La syntaxe du filtre varie selon le type de champ que vous filtrez.</para>
          <para>String (pour les champs de texte) </para>
          <para>Lors de la recherche de champs de texte, vous pouvez utiliser une apostrophe (') ou des guillemets doubles ("") pour délimiter les valeurs qui font partie du filtre. Par exemple, toutes les lignes suivantes fonctionnent correctement lorsque le champ est de type <b>chaîne</b> (<b>String</b> en C#): </para>
          <para>sFilter = "[CompanyName] = 'Microsoft'" </para>
          <para>sFilter = "[CompanyName] =" "Microsoft" "" </para>
          <para>sFilter = "[CompanyName] =" &amp; Chr (34) &amp; "Microsoft" &amp; Chr (34)</para>
          <para>Lorsqu'il s'agit de spécifier un filtre dans une requête Jet ou DASL, si vous utilisez une paire de guillemets simples pour délimiter une chaîne qui fait partie de ce filtre et que le chaîne contient un autre guillemet simple ou une apostrophe, ajoutez un guillemet simple en guise de caractère d'échappement avant le guillemet simple ou l'apostrophe. Adoptez la même approche si vous utilisez une paire de guillemets doubles pour délimier une chaîne : si la chaîne contient un guillemet double, ajoutez un guillemet double en guise de caractère d'échappement avant le guillemet double.</para>
          <para>Par exemple, dans la chaîne de filtre DASL qui filtre la propriété <b>Subject</b> est égale à la valeur de Word not, la chaîne de filtrage entière est délimitée par une paire de guillemets et la chaîne incorporée ne peut pas être délimitée par une paire de guillemets simples. Cette chaîne de filtrage comporte trois caractères que vous devez ignorer: les guillemets de début et de fin pour la référence de propriété de http://schemas.microsoft.com/mapi/proptag/0x0037001f, et l'apostrophe dans la condition de valeur pour le mot est introuvable. En appliquant les caractères d'échappement appropriés, vous pouvez exprimer la chaîne de filtre comme suit :</para>
          <para>Filter = "@SQL=" "http://schemas.microsoft.com/mapi/proptag/0x0037001f" "=" Can' "</para>
          <para>Vous pouvez également utiliser la fonction chr(34) pour représenter le guillemet double (dont la valeur de caractère ASCII est 34) utilisé comme caractère d’échappement. En utilisant chr(34) à la place d’un caractère d’échappement de type guillemet double, vous pouvez exprimer le dernier exemple comme suit :</para>
          <para>Filter = "@SQL=" &amp; Chr (34) &amp; "http://schemas.microsoft.com/mapi/proptag/0x0037001f" _</para>
          <para>    &amp;Chr (34) &amp; "=" &amp; "' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '</para>
          <para>Il est également nécessaire d’utiliser des caractères d’échappement pour les guillemets simples et doubles figurant dans les requêtes DASL à l’aide des opérateurs <b>ci_startswith</b> ou <b>ci_phrasematch</b>. Par exemple, la requête suivante exécute une requête de correspondance d’expression pour can’t dans l’objet du message : </para>
          <para>Filter = "@SQL=" &amp; Chr (34) &amp; "http://schemas.microsoft.com/mapi/proptag/0x0037001E" _</para>
          <para>    &amp;Chr (34) &amp; "ci_phrasematch" &amp; "'ne peut pas'</para>
          <para>Un autre exemple est une chaîne de filtre DASL qui filtre la propriété <b>Subject</b> égale aux mots, où le mot est placé entre guillemets. Dans ce cas, vous devez ajouter des caractères d'échappement pour les guillemets doubles comme suit :</para>
          <para>Filter = "@SQL=" "http://schemas.microsoft.com/mapi/proptag/0x0037001f" "=" droite "" Stuff "" ' "</para>
          <para>Un ensemble de règles d’échappement différent s’applique à une référence de propriété pour les propriétés nommées contenant l’espace, un guillemet simple, double guillemets ou caractère pourcentage. Pour plus d’informations, voir Référencement des propriétés par Espace de noms.</para>
          <para>Date</para>
          <para>Bien que les dates et les heures soient généralement stockées à l’aide d’un format Date, les méthodes <b>Find</b> et <b>Restrict</b> nécessitent que la date et l’heure soient converties en une représentation de chaîne. Pour vérifier que la date est mise en forme comme prévu dans Microsoft Outlook, utilisez la fonction <b>Format</b>. L'exemple de code suivant montre comment créer un filtre pour rechercher tous les contacts modifiés après le 15 janvier 1999 à 15:30. </para>
          <para>sFilter = "[LastModificationTime] &gt; '" &amp; format ("1/15/99 3:30pm", "ddddd h:NN AMPM") &amp; "'"</para>
          <para>Opérateurs booléens</para>
          <para>Les opérateurs Boolean, TRUE/FALSE, YES/NO, ON/OFF, etc, ne doivent pas être convertis en chaîne. Par exemple, pour déterminer si la journalisation est activée pour les contacts, utilisez ce filtre :</para>
          <para>sFilter = "[Journal] = true" </para>
          <para>
            <b>Remarque</b>: Si vous utilisez des guillemets comme délimiteurs <b></b> avec des champs booléens, une chaîne vide trouvera alors les éléments dont les champs ont la <b>valeur false</b> et toutes les chaînes non vides trouveront les éléments dont les champs ont la <b>valeur true</b>. </para>
          <para>Mots clés (ou catégories)</para>
          <para>Le champ catégories est de type Mots clés, qui est conçu pour contenir plusieurs valeurs. Lorsque vous accédez au champ Catégories via un programme, celui-ci se comporte comme un champ de texte, et la chaîne doit correspondre exactement à la valeur recherchée. Les valeurs dans la chaîne de texte sont séparées par une virgule et un espace. Cela signifie généralement que vous ne pouvez pas utiliser les méthodes <b>Find</b> et <b>Restrict</b> sur un champ de mots clés s'il contient plusieurs valeurs. Par exemple, si un contact appartient à la catégorie Business et si un contact appartient aux catégories Business et Social, il n'est pas facile d'utiliser les méthodes <b>Find</b> et <b>Restrict</b> pour extraire tous les éléments qui se trouvent dans la catégorie Business. Il est préférable, dans ce cas, d'effectuer une recherche dans les contacts du dossier et d'utiliser la fonction <b>Instr</b> pour vérifier si la chaîne « Business » est contenue dans le champ des mots clés. </para>
          <para>
            <b>Remarque</b>: une exception possible est si vous limitez le champ catégories à deux ou un petit nombre de valeurs. Vous pouvez alors utiliser les méthodes <b>Find</b> et <b>Restrict</b> avec l’opérateur logique OR pour récupérer tous les contacts de la catégorie Business. Par exemple (en pseudocode) : "Business" OR "Business, Personal" OR "Personal, Business." Les chaînes de catégorie ne sont pas sensibles à la casse. </para>
          <para>Entier</para>
          <para>Vous pouvez rechercher les champs de type <b>Integer</b> avec ou sans guillemets comme délimiteurs. Les filtres suivants retrouveront les contacts qui ont été créés avec Outlook 2000 : </para>
          <para>sFilter = "[OutlookInternalVersion] = 92711" </para>
          <para>sFilter = "[OutlookInternalVersion] = ' 92711 '"</para>
          <para>Utilisation de variables comme partie du filtre</para>
          <para>Comme l'illustre l'exemple de la méthode <b>Restrict</b>, vous pouvez utiliser des valeurs issues de variables dans le filtre. L'exemple de code Microsoft Visual Basic suivant illustre la syntaxe qui utilise des variables dans le cadre du filtre. </para>
          <para>sFullName = "Dan Wilson" </para>
          <para>'Cette approche utilise Chr (34) pour délimiter la valeur. </para>
          <para>sFilter = "[FullName] =" &amp; Chr (34) &amp; sFullName &amp; Chr (34) </para>
          <para>'Cette approche utilise des guillemets doubles pour délimiter la valeur. </para>
          <para>sFilter = "[FullName] =" "" &amp; sFullName &amp; "" ""</para>
          <para>Utilisation d’opérateurs logiques dans le cadre du filtre</para>
          <para>Les opérateurs logiques qui sont autorisés sont AND, OR, et NOT. Voici des variantes de la clause pour la <b></b> méthode Restrict afin que vous puissiez spécifier plusieurs critères.  </para>
          <para>OR : le code suivant renvoie tous les contacts dont la catégorie est Business ou Personal. </para>
          <para>sFilter = "[categories] = 'personnel'ou [categories] = 'Business'" </para>
          <para>AND : Le code suivant extrait tous les contacts personnels travaillant à Microsoft. </para>
          <para>sFilter = "[categories] = 'Personal'and [CompanyName] = 'Microsoft'" </para>
          <para>NOT : Le code suivant extrait tous les contacts personnels qui ne travaillent pas à Microsoft. </para>
          <para>sFilter = "[categories] = 'personnel'et non ([CompanyName] = 'Microsoft')"</para>
          <para>Notes supplémentaires</para>
          <para>Si vous essayez d'utiliser les méthodes <b>Find</b> ou <b>Restrict</b> avec des champs définis par l'utilisateur, ces champs doivent être définis dans le dossier, sinon, une erreur se produit. Il n'existe aucun moyen d'effectuer une opération « contains (contient) ». Par exemple, vous ne pouvez pas utiliser <b>Find</b> ou <b>Restrict</b> pour rechercher des éléments dont le champ Objet contient un mot particulier. Au lieu de cela, vous <see cref="M:Microsoft.Office.Interop.Outlook._Application.AdvancedSearch(System.String,System.Object,System.Object,System.Object)" /> pouvez utiliser la méthode, ou vous pouvez parcourir tous les éléments du dossier et utiliser la <b></b> fonction InStr pour effectuer une recherche dans un champ. Vous pouvez utiliser la méthode <b>Restrict</b> pour rechercher des éléments commençant par un caractère particulier. Par exemple, pour rechercher tous les contacts dont le nom de famille commence par la lettre M, utilisez le filtre suivant : </para>
          <para>sFilter = "[nom] &gt; 'LZZZ'et [nom] &lt; 'N'"</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.NameSpace Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.NameSpace Session" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As NameSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::NameSpace ^ Session { Microsoft::Office::Interop::Outlook::NameSpace ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61451)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61451)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.NameSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Renvoie l' <see cref="T:Microsoft.Office.Interop.Outlook.NameSpace" /> objet de la session en cours. Lecture seule.</summary>
        <value>To be added.</value>
        <remarks><para>La propriété <b>session</b> et la <see cref="M:Microsoft.Office.Interop.Outlook._Application.GetNamespace(System.String)" /> méthode peuvent être utilisées de façon interchangeable pour obtenir l'objet <b>namespace</b> de la session en cours. Les deux membres présentent la même utilité. Par exemple, les paires d'instructions suivantes exécutent la même fonction:</para>
          <code>Dim objNamespace As Outlook.NameSpace = _
    Application.GetNamespace("MAPI")</code>
          <code>Dim objSession As Outlook.NameSpace = Application.Session</code>
          <code>Outlook.NameSpace objNamespace = 
    Application.GetNamespace("MAPI");</code>
          <code>Outlook.NameSpace objSession = Application.Session;</code>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="SetColumns">
      <MemberSignature Language="C#" Value="public void SetColumns (string Columns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetColumns([in]string Columns) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.SetColumns(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetColumns (Columns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetColumns(System::String ^ Columns);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(92)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Columns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Columns">Chaîne qui contient les noms des propriétés à mettre en chache. Les noms de propriétés sont délimités par des virgules dans cette chaîne.</param>
        <summary>Met en cache certaines propriétés d’un élément de la collection pour permettre d’y accéder très rapidement.</summary>
        <remarks><para>La méthode <b>SetColumns</b> est utile pour parcourir la <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> collection. Si vous n'utilisez pas cette méthode, Microsoft Outlook doit ouvrir chaque élément pour accéder à la propriété. Avec la méthode <b>SetColumns</b>, Outlook vérifie uniquement les propriétés que vous avez placées en mémoire cache et fournit un accès rapide et en lecture seule à ces propriétés.</para>
          <para>Après avoir appliqué la méthode <b>SetColumns</b> à des propriétés spécifiques de la collection, vous ne pouvez pas lire les autres propriétés de cette collection ; les propriétés qui ne sont pas mises en cache sont renvoyées vides. Vous n’avez pas non plus la possibilité d’écrire dans les propriétés de cette collection. En guise d'alternative, si vous avez besoin d'un accès en lecture et en écriture rapide à <see cref="T:Microsoft.Office.Interop.Outlook.Table" /> un ensemble d'éléments, utilisez l'objet.</para>
          <para>La méthode 
            <b>SetColumns</b> ne peut pas être utilisée avec les propriétés qui renvoient un objet (une erreur sera générée). Elle ne peut pas être utilisée avec les propriétés suivantes :</para>
          <list type="table">
            <item>
              <description>AutoResolvedWinner</description>
              <description>InternetCodePage</description>
            </item>
            <item>
              <description>Corps</description>
              <description>MeetingWorkspaceURL</description>
            </item>
            <item>
              <description>BodyFormat</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.MemberCount" />
              </description>
            </item>
            <item>
              <description>Catégories</description>
              <description>ReceivedByEntryID</description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.Children" />
              </description>
              <description>ReceivedOnBehalfOfEntryID</description>
            </item>
            <item>
              <description>Classe</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.RecurrenceState" />
              </description>
            </item>
            <item>
              <description>Sociétés</description>
              <description>ReplyRecipients</description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.DLName" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._TaskItem.ResponseState" />
              </description>
            </item>
            <item>
              <description>DownloadState</description>
              <description>Saved</description>
            </item>
            <item>
              <description>EntryID</description>
              <description>Sent</description>
            </item>
            <item>
              <description>HTMLBody</description>
              <description>Submitted</description>
            </item>
            <item>
              <description>IsConflict</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._MailItem.VotingOptions" />
              </description>
            </item>
          </list>
          <para>La propriété <b>ConversationIndex</b> ne peut pas être mise en cache à l’aide de la méthode <b>SetColumns</b>. Toutefois, cette propriété ne génèrera pas d’erreur, contrairement aux autres propriétés répertoriées ci-dessus.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (string Property, object Descending);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort([in]string Property, [in]object Descending) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Sort(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (Property As String, Optional Descending As Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(97)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Property" Type="System.String" />
        <Parameter Name="Descending" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Property">Nom de la propriété à utiliser pour le tri, qui peut être placé entre crochets, par exemple, «[CompanyName]». Les propriétés définies par l'utilisateur qui contiennent des espaces doivent être placées entre crochets. N'est peut-être pas une propriété définie par l'utilisateur de type Mots clés, et peut ne pas être une propriété à valeurs multiples, telle qu'une catégorie. Pour les propriétés définies par l'utilisateur, la propriété doit exister <b></b> dans la collection <see cref="P:Microsoft.Office.Interop.Outlook._Items.Parent" />UserDefinedProperties de, qui <see cref="T:Microsoft.Office.Interop.Outlook.Folder" /> représente l'objet contenant les éléments.</param>
        <param name="Descending">Cet argument à la valeur <b>True</b> pour un tri par ordre décroissant. La valeur par défaut est <b>False</b> (croissant).</param>
        <summary>Trie la collection d'éléments en fonction de la propriété spécifiée. L'index de cette collection est ramené à 1 après exécution de cette méthode.</summary>
        <remarks><para>La méthode 
            <b>Sort</b> affecte uniquement l'ordre des éléments d'une collection. Elle n'affecte pas l'ordre des éléments dans un affichage d'explorateur.</para>
          <para>L'opération 
            <b>sort</b> ne peut pas être utilisée et génère une <paramref name="property" /> erreur si le paramètre est l'une des propriétés suivantes:                </para>
          <list type="table">
            <item>
              <description>
                <b>Catégories</b>
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstSpaceOnly" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.Children" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstSpaceOnlyCompany" />
              </description>
            </item>
            <item>
              <description>
                <b>Classe</b>
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.MemberCount" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.CompanyLastFirstNoSpace" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.NetMeetingAlias" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.CompanyLastFirstSpaceOnly" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.RecurrenceState" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.DLName" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._TaskItem.ResponseState" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstAndSuffix" />
              </description>
              <description>
                <b>Saved</b>
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstNoSpace" />
              </description>
              <description>
                <b>Messages envoyés</b>
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstNoSpaceCompany" />
              </description>
              <description />
            </item>
          </list>
          <para> </para></remarks>
      </Docs>
    </Member>
  </Members>
</Type>
